---
layout:     post
title:      "各种排序算法"
subtitle:   " \"learning……\""
date:       2025-01-05 09:45:00
author:     "Ryan"
header-img: "img/bg-walle.jpg"
catalog: true
tags:
    - c++
    - 基础算法
---


# 千奇百怪的排序算法  

![image](https://github.com/user-attachments/assets/6520bf80-977f-4b7a-b0d1-95d88cf049d4)

![image](https://github.com/user-attachments/assets/0a194524-cf51-420a-9224-8c69c5a058f0)


1. 冒泡排序，无脑两两比较交换，稳定
2. 选择排序，每次遍历将目标值（最大/最小）筛选出来填到预留位置（最前/最后），指针后移，不稳定，选择比冒泡比较次数少
3. 插入排序，指针从第二个位置开始遍历，每次遍历将该数插入到前一段已经排好序的数组（数据后移），稳定，比选择排序比较次数少
4. 希尔排序，插入排序+分组，先定gap，一般是长度除二，然后每一轮（gap->全局分组->组内插排->gap/2），gap为1时，整个数组分为一组，相当于进行插排
5. 快速排序，分治递归（二叉树），左右指针不相遇，每次遍历选取基准数，将大于基准数的排到右边，小于的排到左边，返回基准数位置pivotindex，然后进行分治partition
6. 归并排序，分治递归（彻底的二分法分区），先序列化分（二分到只有一个），再进行元素的有序合并（数据合并时进行排序）
7. 堆排序，使用了最小堆（最大堆）优先级队列技术。先把数组最大堆化，然后每次循环取出最大堆堆顶放置末尾，末尾放置堆头，然后从堆头开始进行最大堆下沉（末尾排除）
8. 桶排序，先根据数据范围，划分多个桶，将数据分别入桶，桶内排序方式自主选择，排完后数据合并即可
9. 基数排序，数以链表形式排列，创建基数个桶（比如十进制数是0-9总共十个桶），遍历链表放入个位对应基数的桶，然后遍历桶，将链表重新连接；再对更高位进行分桶和合并
10. 拓扑排序，有向无环图的排序，从入度为0的结点开始，删除其节点以及节点所有的有向边，然后重复选择入度为零的节点以及删除的操作，直到没有节点（有环图会有节点剩余）
11. leetcode 75.颜色分类练习


# 常用排序算法  
以下是一些最基本的排序算法。虽然在 C++ 里可以通过 std::sort() 快速排序，而且刷题时很少需要自己手写排序算法，但是熟习各种排序算法可以加深自己对算法的基本理解，以及解出由这些排序算法引申出来的题目。

### STL中sort的底层实现  
快排优化  
* 当排的数过少时，当前递归采用插排（n<32）。
* 当递归深度过深时，转为堆排序。
* 为防止O(n2)退化，采用三数取中法。


### 冒泡排序  
````
void BubbleSort(vector<int>& nums)
{
    for(int i=0;i<nums.size()-1;++i)
    {
        int flag=1;
        for(int j=0;j<nums.size()-i-1;++j)
        {
            if(nums[j]>nums[j+1])
            {
                swap(nums[j],nums[j+1]);
                flag=0;
            }
        }
        if(flag) return;
    }
}
````

### 选择排序  
````
void SelectSort(vector<int>& nums)
{
    int n=nums.size();
    for(int i=0;i<n;i++)
    {
        int minindex=i;
        for(int j=i+1;j<n;j++)
        {
            if(nums[j]<nums[minindex]) minindex=j;
        }
        if(minindex!=i) swap(nums[minindex],nums[i]);
    }
}
````

### 插入排序  
````

````









